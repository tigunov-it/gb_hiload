<?php

namespace App\Handlers\Sort;

class QuickSort implements SortInterface
{

    function sortArr($array): array
    {
        // count () возвращает количество элементов в массиве
        $count = count($array);

        // Определяем, нужна ли сортировка (исключая не массив, а количество элементов массива меньше или равно 1)
        if ($count <= 1) return $array;

        // Определяем промежуточное значение, которое является ссылочным значением
        $baseValue = $array[0];
        /**
         * Определить два пустых массива для разделения исходного массива слева и справа
         * $ leftArr хранит массив меньше, чем эталонное значение, которое является левым разделом
         * $ rightArr хранит массив больше, чем эталонное значение, которое является правильным разделом
         */

        $leftArr = $rightArr = array();

        // Сравнить среднее значение массива, обратить внимание на значение $ i, начиная с 1 (или $ i = 0; $ i <$ count-1)
        for ($i = 1; $i < $count; $i++) {
            if ($baseValue > $array[$i]) {
                // Меньше значения эталона помещается в левый раздел
                $leftArr[] = $array[$i];
            } else {
                // Меньше, чем эталонное значение помещается в правильный раздел
                $rightArr[] = $array[$i];
            }
        }

        // Рекурсивная сортировка подпоследовательностей элементов, меньших, чем контрольное значение, и подпоследовательностей элементов, превышающих контрольное значение
        $leftArr = $this->sortArr($leftArr);
        $rightArr = $this->sortArr($rightArr);

        // Возвращаем объединенный и отсортированный массив, помещаем значения эталона в массив и объединяем их вместе, обращаем внимание на порядок, левый раздел помещается впереди, значение эталона размещается посередине, а правый раздел помещается сзади
        return array_merge((array)$leftArr, array($baseValue), (array)$rightArr);

    }
}
